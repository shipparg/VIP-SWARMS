# test implementation of spline based movement
import numpy as np

import airsimneurips
from scipy.interpolate import CubicSpline

client = airsimneurips.MultirotorClient()
client.confirmConnection()
print('connection confirmed')


# client.simLoadLevel('Soccer_Field_Easy')
NUM_WAYPOINTS = 8

def gatePos():
    all_objects = client.simListSceneObjects(name_regex='.*')
    gates = [obj for obj in all_objects if 'Gate' in obj]
    pos_dict = {}
    for gate_name in gates:
        gate_position = client.simGetObjectPose(gate_name).position
        gate_number = int(gate_name[4:6])
        pos_dict.update({gate_number: gate_position})
    sorted_dict = {k: pos_dict[k] for k in sorted(pos_dict)}
    return sorted_dict


def gateNametoNum():
    all_objects = client.simListSceneObjects(name_regex='.*')
    gates = [obj for obj in all_objects if 'Gate' in obj]
    gNumtoName = {}  # stores the gate_numbers and corr. name
    gate_number = 0
    for gate_name in gates:
        gNumtoName[gate_number] = gate_name
        gate_number += 1
    return gNumtoName


def enable():
    client.enableApiControl(vehicle_name="drone_1")  # Enable API control for the drone
    client.arm(vehicle_name="drone_1")  # Arm the drone so it can take off
    client.simStartRace()
    client.takeoffAsync(vehicle_name='drone_1').join()


# here we try to set up the co-ordinates for the sphere and the corresponding co-ordinates
def sphere(pos_dict):
    sphereCods = {}
    gNametoNum = gateNametoNum()
    radius = 2  # radius of the sphere (how do we pick the radius?)
    for gate_number in pos_dict.keys():
        new_pos = client.simGetObjectPose(gNametoNum[gate_number]).position
        x_min = new_pos.x_val - radius
        x_max = new_pos.x_val + radius
        y_min = new_pos.y_val - radius
        y_max = new_pos.y_val + radius
        z_min = new_pos.z_val - radius
        z_max = new_pos.z_val + radius
        sphereCods[gate_number] = [x_min, x_max, y_min, y_max, z_min, z_max]
    return sphereCods


def simplemove(gateInfo):  # gateInfo is just posDict[key]
    client.moveToPositionAsync(gateInfo.x_val, gateInfo.y_val, gateInfo.z_val,
                               5)  # we need to dynamically set this vel value at a later date


def generate_spline(posDict):
    # this function finds the trajectory between any two successive gates, and stores it in a large dictionary
    # given x, y data, we find the cubic polynomial that approximates this length
    # we then use this to generate way points
    # we then use these way points as the next position vectors for the movetoPosAsync
    time = [0, 1]  # stand-in for x
    testwp = {}

    for gate_number in range(len(posDict) - 1):
        # print('gate number is: ', gate_number)
        gate1_pos = posDict[gate_number]
        gate2_pos = posDict[gate_number + 1]

        # we find the trajectory
        trajX = CubicSpline(time, [gate1_pos.x_val, gate2_pos.x_val])
        trajY = CubicSpline(time, [gate1_pos.y_val, gate2_pos.y_val])
        trajZ = CubicSpline(time, [gate1_pos.z_val, gate2_pos.z_val])

        # now we create the waypoints
        numWaypoints = NUM_WAYPOINTS
        timeWaypoints = np.linspace(0, 1, numWaypoints)
        waypoints = []  # stores all the x and y trajectory values between gates

        # we now iterate through the timeWaypoints and put them in the trajectories to find new X trajectory
        for t in timeWaypoints:
            # print('value of t is:', t, gate_number)
            x_val = round(float(trajX(t)), 2)
            y_val = round(float(trajY(t)), 2)
            z_val = round(float(trajZ(t)), 2)
            waypoints.append([x_val, y_val, z_val])

        # print('Trajectory from Gate', gate_number,'to', gate_number + 1, ': ', waypoints)
        testwp[gate_number] = waypoints
    return testwp


def sphere_condition(sphere_info, gate_number):
    # check whether the drone is within the sphere or not
    # if so, we need to immediately change focus to the next target by updating movePosAsync
    current_pos = client.getMultirotorState(vehicle_name='drone_1').kinematics_estimated.position
    if sphere_info[gate_number][0] < current_pos.x_val < sphere_info[gate_number][1]:
        if sphere_info[gate_number][2] < current_pos.y_val < sphere_info[gate_number][3]:
            if sphere_info[gate_number][4] < current_pos.z_val < sphere_info[gate_number][5]:
                return True
    else:
        return False


def spline_movement(spline, sphereData):
    # first, move the drone to the positions generated by the spline
    for waypoint in spline:
        posNum = 0
        while posNum < NUM_WAYPOINTS:
            print('waypoint is: ', spline[waypoint][posNum])
            client.moveToPositionAsync(spline[waypoint][posNum][0], spline[waypoint][posNum][1],
                                       spline[waypoint][posNum][2], 6).join()
            posNum += 1

        # now we continuously check for the sphere condition
        # while not (sphere_condition(sphereData, waypoint + 1)):
        #     print('stuck here')
        #     pass

if __name__ == '__main__':
    enable()

    gateInfo = gatePos()  # returns the gate positions
    # print(gateInfo)

    sphereData = sphere(gateInfo)
    # print('sphere data is:' , sphereData[0])

    spline = generate_spline(gateInfo)
    # print(spline)

    spline_movement(spline, sphereData)
    print("move commands complete")
